"""
Authentication for private methods of the API (mainly managing deployments)

Implementation notes:
====================
Authentication is implemented using `get_user_infos_from_access_token` instead
of `get_user_infos_from_request` (as done in the FastAPI example in the flaat docs).
There are two advantages of this:
* the main one is that it would enable us enable to take advantage of Swagger's builtin
  Authentication and Authorization [1] in the Swagger interface (generated by FastAPI).
  This is not possible using the `Request` object, as data from `Request` cannot be validated and
  documented by OpenAPI [2].

  [1] https://swagger.io/docs/specification/authentication/
  [2] https://fastapi.tiangolo.com/advanced/using-request-directly/?h=request#details-about-the-request-object

* the decorator `flaat.is_authenticated()` around each function is no longer needed,
  as authentication is checked automatically by `authorization=Depends(security)` without needing extra code.

The curl calls still remain the same, but now in the http://localhost/docs you will see an authorize
 button where you can copy paste your token. So you will be able to access authenticated methods from the interface.
"""

import re

from fastapi import HTTPException
import jwt


KEYCLOAK_URL = "https://login.cloud.ai4eosc.eu/realms/ai4eosc"
jwk_client = jwt.PyJWKClient(f"{KEYCLOAK_URL}/protocol/openid-connect/certs")


def get_user_info(token):
    try:
        signing_key = jwk_client.get_signing_key_from_jwt(token).key
        user_infos = jwt.decode(
            token,
            signing_key,
            audience="account",  # needed for Vault
            issuer=KEYCLOAK_URL,
            algorithms=["RS256"],
            options={
                "require": ["sub", "iss", "name", "email"],
                "verify_signature": True,
                "verify_exp": True,
                "verify_iss": True,
                "verify_aud": True,
            },
        )
    except Exception as e:
        raise HTTPException(
            status_code=401,
            detail=str(e),
        )

    # Create a group dictionary where keys are the access levels and values are the
    # projects that enabled the user into that access level.
    # eg. {"ap-a": ["vo.ai4eosc.eu", "vo.imagine-ai.eu"]}
    groups = {}
    for role in user_infos.get("realm_access", {}).get("roles", []):
        # Roles should be structured as "access:<vo>:<level>"
        match = re.match(r"access:(?P<vo>[^:]+):(?P<level>.+)", role)
        if not match:
            continue
        groups.setdefault(match["level"], [])
        groups[match["level"]].append(match["vo"])

    out = {
        "id": user_infos.get("sub"),  # subject, user-ID
        "issuer": user_infos.get("iss"),  # URL of the access token issuer
        "name": user_infos.get("name"),
        "email": user_infos.get("email"),
        "groups": groups,
    }

    return out


def check_authorization(
    auth_info: dict,
    requested_vo: str = None,
    access_level: str = "ap-u",
):
    """
    Check that the user has permissions to use the resource (usually "ap-u")
    and check he indeed belongs to the requested VO.
    """
    if access_level not in auth_info["groups"].keys():
        raise HTTPException(
            status_code=401,
            detail=f"Your user has not the required access level to use this resource: {access_level}.",
        )

    user_vos = auth_info["groups"][access_level]
    if requested_vo and (requested_vo not in user_vos):
        raise HTTPException(
            status_code=401,
            detail=f"The requested Virtual Organization ({requested_vo}) does not match with any of your available VOs for that access level: {user_vos}.",
        )
